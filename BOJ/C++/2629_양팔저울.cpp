/*
문제
양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

구슬이 3g인 경우 아래 <그림 1>과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.



<그림 2>와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.

추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.



입력
첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있 다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.

출력
주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.

풀이:
dp[i][j] => i번째 추까지 모두 사용했을 때 j의 무게를 잴 수 있는지 여부

추로 만들 수 있는 최대 무게를 미리 구한다.(limit)

각 추마다 limit까지 돌면서 현재 무게 j 에서 현재 추 w 를 뺏을 때 이전까지(i - 1)에서 그 무게를 만들 수 있다면
현재 추를 더한 것도 만들 수 있으므로 dp[i][j] = true 이다.

구슬의 옆에 추를 놓는 경우는 abs(j - w) 로 생각해 준다.
*/
#include<iostream>
#include<memory.h>
#include<algorithm>
#include<math.h>
#include<string>
#include<vector>
#include<stack>
#include<queue>
#include<map>
#include<set>
using namespace std;
#define FIO ios_base::sync_with_stdio(false); cin.tie(NULL)
#define pii pair<int, int>
#define pdd pair<double, double>
#define pic pair<int, char>
#define ll long long
#define pll pair<ll, ll>
#define vi vector<int>
#define vl vector<long long>
#define vc vector<char>
#define vii vector<pii>
#define IMAX 2000000001
#define LMAX 1000000000000000000
#define DMAX 0xFFFFFFFFFFFFF
#define MOD 20091101
int mv1[4] = { 0, 0, 1, -1 };
int mv2[4] = { 1, -1, 0, 0 };
int mv_all1[8] = { 0, 1, 0, -1, -1, -1, 1, 1 };
int mv_all2[8] = { 1, 0, -1, 0 , -1, 1, -1, 1 };

bool dp[31][40001];

int main(void) {
	FIO;

	int n, m;
	cin >> n;

	vector<int> chu;
	int limit = 0;

	for (int i = 0; i < n; i++)
	{
		int w;
		cin >> w;
		chu.push_back(w);
		limit += w;
	}

	dp[0][0] = true;

	for (int i = 1; i <= n; i++)
	{
		int w = chu[i - 1];

		for (int j = 0; j <= limit; j++)
		{
			if (dp[i - 1][abs(j - w)])
				dp[i][j] = true;
			if (dp[i - 1][j]) {
				dp[i][j] = true;
				dp[i][abs(j - w)] = true;
			}
		}
	}

	cin >> m;

	for (int i = 0; i < m; i++)
	{
		int w;
		cin >> w;

		if (dp[n][w])
			cout << "Y ";
		else
			cout << "N ";
	}
}